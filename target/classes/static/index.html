<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orochi System Health Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.4/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.1/dist/chartjs-adapter-moment.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css">
    <style>
        :root {
            --dark-bg: #121212;
            --dark-card: #1e1e1e;
            --dark-header: #252525;
            --dark-text: #e0e0e0;
            --dark-secondary: #aaaaaa;
            --dark-border: #333333;
            --accent-color: #4da6ff;
            --danger-color: #ff4d4d;
            --success-color: #4dff4d;
            --warning-color: #ffcc00;
            --info-color: #9966ff;
        }
        
        body {
            background-color: var(--dark-bg);
            color: var(--dark-text);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .dashboard-container {
            padding: 20px;
        }
        
        .metric-card {
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            background-color: var(--dark-card);
            border: 1px solid var(--dark-border);
            border-radius: 10px;
            overflow: hidden;
            transition: all 0.3s ease;
            height: calc(100% - 20px);
        }
        
        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.5);
        }
        
        .metric-card-header {
            background: linear-gradient(90deg, var(--dark-header), #2a2a2a);
            border-bottom: none;
            padding: 15px;
            font-weight: bold;
            color: var(--dark-text);
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .metric-card-header i {
            margin-right: 10px;
            font-size: 1.3rem;
            background: linear-gradient(135deg, var(--accent-color), var(--warning-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .card {
            background-color: var(--dark-card);
            border: 1px solid var(--dark-border);
            color: var(--dark-text);
        }
        
        .card-body {
            padding: 20px;
        }
        
        .metric-value {
            font-size: 28px;
            font-weight: bold;
            color: var(--accent-color);
            margin-top: 10px;
            text-shadow: 0 0 10px rgba(77, 166, 255, 0.3);
        }
        
        .metric-memory {
            color: var(--warning-color);
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.3);
        }
        
        .history-table {
            font-size: 0.875rem;
            margin-top: 15px;
        }
        
        .refresh-btn {
            margin-bottom: 20px;
            background-color: var(--accent-color);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        
        .refresh-btn:hover {
            background-color: #3a80cc;
            transform: translateY(-2px);
        }
        
        .refresh-btn:active {
            transform: translateY(0);
        }
        
        .timestamp {
            font-size: 0.75rem;
            color: var(--dark-secondary);
        }
        
        .container-details {
            display: none;
            background-color: #252525;
            border-top: 1px solid var(--dark-border);
            padding: 10px;
            margin-top: 10px;
        }
        
        .container-row {
            cursor: pointer;
        }
        
        .container-row:hover {
            background-color: #2a2a2a;
        }
        
        .table {
            color: var(--dark-text);
            border-color: var(--dark-border);
        }
        
        .table-hover tbody tr:hover {
            background-color: #2a2a2a;
            color: var(--dark-text);
        }
        
        .table thead th {
            border-bottom-color: var(--dark-border);
            font-weight: 600;
            color: var(--accent-color);
        }
        
        .table td, .table th {
            border-top-color: var(--dark-border);
            padding: 12px 15px;
            vertical-align: middle;
        }
        
        .stream-active {
            color: var(--success-color);
            font-weight: bold;
            padding: 5px 10px;
            background-color: rgba(77, 255, 77, 0.1);
            border-radius: 20px;
            display: inline-block;
        }
        
        .stream-inactive {
            color: var(--danger-color);
            font-weight: bold;
            padding: 5px 10px;
            background-color: rgba(255, 77, 77, 0.1);
            border-radius: 20px;
            display: inline-block;
        }
        
        .badge-up {
            background-color: var(--success-color);
            color: #000;
        }
        
        .icon-available {
            color: var(--success-color);
        }
        
        .icon-unavailable {
            color: #444;
        }
        
        .server-info {
            background-color: var(--dark-header);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 25px;
            border: 1px solid var(--dark-border);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .server-selector {
            margin-left: 20px;
        }
        
        .form-select {
            background-color: var(--dark-card);
            color: var(--dark-text);
            border-color: var(--dark-border);
            border-radius: 20px;
            padding: 8px 15px;
        }
        
        .form-select option {
            background-color: var(--dark-card);
            color: var(--dark-text);
        }
        
        .chart-container {
            position: relative;
            height: 180px;
            margin-top: 20px;
            margin-bottom: 20px;
        }
        
        .progress {
            background-color: var(--dark-border);
            height: 10px;
            border-radius: 5px;
            margin-top: 10px;
            margin-bottom: 10px;
            overflow: hidden;
        }
        
        .progress-bar-cpu {
            background-color: var(--accent-color);
            background-image: linear-gradient(45deg, rgba(255,255,255,.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.15) 50%, rgba(255,255,255,.15) 75%, transparent 75%, transparent);
            background-size: 1rem 1rem;
            animation: progress-bar-stripes 1s linear infinite;
        }
        
        .progress-bar-memory {
            background-color: var(--warning-color);
            background-image: linear-gradient(45deg, rgba(255,255,255,.15) 25%, transparent 25%, transparent 50%, rgba(255,255,255,.15) 50%, rgba(255,255,255,.15) 75%, transparent 75%, transparent);
            background-size: 1rem 1rem;
            animation: progress-bar-stripes 1s linear infinite;
        }
        
        .progress-bar-storage {
            background-color: var(--success-color);
        }
        
        @keyframes progress-bar-stripes {
            from { background-position: 1rem 0; }
            to { background-position: 0 0; }
        }
        
        .text-danger {
            color: var(--danger-color) !important;
        }
        
        .text-success {
            color: var(--success-color) !important;
        }
        
        .text-warning {
            color: var(--warning-color) !important;
        }
        
        .text-muted {
            color: var(--dark-secondary) !important;
        }
        
        .metric-label {
            font-size: 0.9rem;
            color: var(--dark-secondary);
            margin-bottom: 5px;
        }
        
        .circular-progress {
            position: relative;
            width: 120px; /* Changed from 80px */
            height: 120px; /* Changed from 80px */
            margin: 0 auto;
        }

        .circular-progress svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }
        
        .circular-progress circle {
            fill: transparent;
            stroke-width: 8;
            stroke-dasharray: 226; /* 2*PI*r where r=36 */
            stroke-dashoffset: 0;
            stroke-linecap: round;
        }
        
        .circular-progress circle.progress-track {
            stroke: rgba(255,255,255,0.1);
        }
        
        .circular-progress circle.progress-bar {
            stroke: var(--accent-color);
            transition: stroke-dashoffset 0.5s ease;
        }
        
        .circular-progress circle.progress-bar-memory {
            stroke: var(--warning-color);
            transition: stroke-dashoffset 0.5s ease;
        }
        

                .circular-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            font-size: 1.5rem; /* Changed from 1.2rem */
            font-weight: bold;
            color: white !important; /* Added to force white text */
            text-shadow: 0 0 5px rgba(0,0,0,0.5); /* Added shadow for better contrast */
        }
        
        .trend-indicator {
            margin-left: 5px;
            font-size: 0.8rem;
        }
        
        .trend-up {
            color: var(--danger-color);
        }
        
        .trend-down {
            color: var(--success-color);
        }
        
        .trend-same {
            color: var(--dark-secondary);
        }
        
        .sparkline {
            height: 20px;
            width: 60px;
            margin-left: 10px;
            display: inline-block;
            vertical-align: middle;
        }
        
        .history-table tbody tr:nth-child(n+4) {
            display: none;
        }
        
        .history-table.expanded tbody tr {
            display: table-row;
        }
        
        .history-header {
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .stat-card {
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            height: 100%;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
        }
        
        .stat-card i {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        
        .stat-card .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-card .stat-label {
            font-size: 0.9rem;
            color: var(--dark-secondary);
        }
        
        .stat-blue {
            background-color: rgba(77, 166, 255, 0.1);
            border: 1px solid rgba(77, 166, 255, 0.3);
        }
        
        .stat-blue i, .stat-blue .stat-value {
            color: var(--accent-color);
        }
        
        .stat-yellow {
            background-color: rgba(255, 204, 0, 0.1);
            border: 1px solid rgba(255, 204, 0, 0.3);
        }
        
        .stat-yellow i, .stat-yellow .stat-value {
            color: var(--warning-color);
        }
        
        .stat-green {
            background-color: rgba(77, 255, 77, 0.1);
            border: 1px solid rgba(77, 255, 77, 0.3);
        }
        
        .stat-green i, .stat-green .stat-value {
            color: var(--success-color);
        }
        
        .stat-red {
            background-color: rgba(255, 77, 77, 0.1);
            border: 1px solid rgba(255, 77, 77, 0.3);
        }
        
        .stat-red i, .stat-red .stat-value {
            color: var(--danger-color);
        }
        
        .stat-purple {
            background-color: rgba(153, 102, 255, 0.1);
            border: 1px solid rgba(153, 102, 255, 0.3);
        }
        
        .stat-purple i, .stat-purple .stat-value {
            color: var(--info-color);
        }
        
        .accordion-button {
            background-color: var(--dark-header) !important;
            color: var(--dark-text) !important;
            border-color: var(--dark-border) !important;
        }
        
        .accordion-button:not(.collapsed) {
            color: var(--accent-color) !important;
        }
        
        .accordion-button:focus {
            box-shadow: 0 0 0 0.25rem rgba(77, 166, 255, 0.25) !important;
        }
        
        .accordion-button::after {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%23e0e0e0'%3e%3cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3e%3c/svg%3e") !important;
        }
        
        .accordion-body {
            background-color: var(--dark-card);
            color: var(--dark-text);
        }
        
        /* Stream history styles */
        .stream-history-container {
            padding: 15px;
        }
        
        .stream-status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        
        .stream-status-active {
            background-color: var(--success-color);
        }
        
        .stream-status-inactive {
            background-color: var(--danger-color);
        }
        
        .stream-info-card {
            background-color: rgba(0,0,0,0.2);
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
        }
        
        /* Docker container detailed stats */
        .docker-stats-details {
            display: none;
            padding: 15px;
            background-color: rgba(0,0,0,0.2);
            border-radius: 5px;
            margin-top: 10px;
        }
        
        .small-chart-container {
            height: 100px;
            margin-top: 10px;
        }
        
        .details-toggle {
            cursor: pointer;
            color: var(--accent-color);
            margin-left: 10px;
        }
        
        .details-toggle:hover {
            text-decoration: underline;
        }
        
        .status-summary {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .status-item {
            background-color: var(--dark-card);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            margin: 5px;
            flex-grow: 1;
            min-width: 120px;
            border: 1px solid var(--dark-border);
        }
        
        .status-value {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .status-label {
            color: var(--dark-secondary);
            font-size: 0.9rem;
        }
        
        /* Custom tooltips */
        .custom-tooltip {
            background-color: var(--dark-header) !important;
            color: var(--dark-text) !important;
            border: 1px solid var(--dark-border) !important;
            padding: 8px !important;
            border-radius: 5px !important;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3) !important;
            font-size: 0.9rem !important;
            pointer-events: none !important;
        }
        
        /* Responsive fixes */
        @media (max-width: 768px) {
            .stat-card {
                margin-bottom: 10px;
            }
            
            .server-selector {
                margin-left: 0;
                margin-top: 10px;
            }
            
            .status-item {
                min-width: 100px;
            }
        }
        
        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        
        .spin-animation {
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="#">
                <i class="bi bi-layers"></i> Orochi System Health Dashboard
            </a>
            <div class="ms-auto">
                <span id="clockDisplay" class="text-muted"></span>
            </div>
        </div>
    </nav>

    <div class="container-fluid dashboard-container">
        <!-- Server Info -->
        <div class="row mb-3">
            <div class="col-md-12">
                <div class="card server-info">
                    <div class="card-body">
                        <div class="d-flex align-items-center flex-wrap">
                            <div>
                                <h5 class="mb-0" id="serverName">Loading server info...</h5>
                                <p class="mb-0 text-muted" id="serverLocation">Location: Unknown</p>
                                <small class="text-muted" id="serverId">ID: Unknown</small>
                                <small class="text-muted ms-3" id="serverOs">OS: Unknown</small>
                            </div>
                            <div class="ms-auto server-selector">
                                <select id="serverSelector" class="form-select">
                                    <option value="">Loading servers...</option>
                                </select>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row mb-3">
            <div class="col-12 col-md-6">
                <button id="refreshBtn" class="btn btn-primary refresh-btn">
                    <i class="bi bi-arrow-clockwise"></i> Refresh Data
                </button>
                <span id="lastUpdated" class="ms-3 timestamp"></span>
            </div>
            <div class="col-12 col-md-6 text-md-end mt-2 mt-md-0">
                <div class="btn-group" role="group">
                    <button type="button" class="btn btn-outline-light" id="refreshInterval" data-interval="0">
                        Auto-refresh: Off
                    </button>
                    <button type="button" class="btn btn-outline-light dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                        <i class="bi bi-clock"></i>
                    </button>
                    <ul class="dropdown-menu dropdown-menu-dark">
                        <li><a class="dropdown-item refresh-option" href="#" data-seconds="0">Off</a></li>
                        <li><a class="dropdown-item refresh-option" href="#" data-seconds="5">Every 5 seconds</a></li>
                        <li><a class="dropdown-item refresh-option" href="#" data-seconds="10">Every 10 seconds</a></li>
                        <li><a class="dropdown-item refresh-option" href="#" data-seconds="30">Every 30 seconds</a></li>
                        <li><a class="dropdown-item refresh-option" href="#" data-seconds="60">Every minute</a></li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Status Overview Cards -->
        <div class="row mb-4">
            <div class="col-6 col-md-4 col-lg-2 mb-3 mb-lg-0">
                <div class="stat-card stat-blue">
                    <i class="bi bi-cpu"></i>
                    <div class="stat-value" id="cpuUsageStat">--</div>
                    <div class="stat-label">CPU Usage</div>
                </div>
            </div>
            <div class="col-6 col-md-4 col-lg-2 mb-3 mb-lg-0">
                <div class="stat-card stat-yellow">
                    <i class="bi bi-memory"></i>
                    <div class="stat-value" id="memoryUsageStat">--</div>
                    <div class="stat-label">Memory Usage</div>
                </div>
            </div>
            <div class="col-6 col-md-4 col-lg-2 mb-3 mb-lg-0">
                <div class="stat-card stat-green">
                    <i class="bi bi-camera-video"></i>
                    <div class="stat-value" id="activeStreamsStat">--</div>
                    <div class="stat-label">Active Streams</div>
                </div>
            </div>
            <div class="col-6 col-md-4 col-lg-2 mb-3 mb-lg-0">
                <div class="stat-card stat-red">
                    <i class="bi bi-exclamation-triangle"></i>
                    <div class="stat-value" id="failedStreamsStat">--</div>
                    <div class="stat-label">Failed Streams</div>
                </div>
            </div>
            <div class="col-6 col-md-4 col-lg-2 mb-3 mb-lg-0">
                <div class="stat-card stat-purple">
                    <i class="bi bi-hdd-stack"></i>
                    <div class="stat-value" id="runningContainersStat">--</div>
                    <div class="stat-label">Running Containers</div>
                </div>
            </div>
            <div class="col-6 col-md-4 col-lg-2 mb-3 mb-lg-0">
                <div class="stat-card" id="systemHealthCard">
                    <i class="bi bi-heart-pulse"></i>
                    <div class="stat-value" id="systemHealthStat">--</div>
                    <div class="stat-label">System Health</div>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- System Metrics -->
            <div class="col-md-6">
                <div class="card metric-card">
                    <div class="metric-card-header">
                        <div>
                            <i class="bi bi-cpu"></i> System CPU
                        </div>
                        <div>
                            <span id="cpuAlertBadge" class="badge bg-success">Normal</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="row align-items-center">
                            <div class="col-4 text-center">
                                <div class="circular-progress" id="cpuCircularProgress">
                                    <svg viewBox="0 0 100 100">
                                        <circle class="progress-track" cx="50" cy="50" r="36"></circle>
                                        <circle class="progress-bar" cx="50" cy="50" r="36"></circle>
                                    </svg>
                                    <div class="circular-progress-text" id="cpuProgressText">0%</div>
                                </div>
                                <div class="mt-2">
                                    <small class="text-muted">Utilization</small>
                                </div>
                            </div>
                            <div class="col-8">
                                <div class="mb-3">
                                    <div class="d-flex justify-content-between">
                                        <span class="metric-label">Utilization</span>
                                        <span class="metric-label" id="cpuUsageLabel">--%</span>
                                    </div>
                                    <div class="progress">
                                        <div id="cpuProgressBar" class="progress-bar progress-bar-cpu" role="progressbar" style="width: 0%"></div>
                                    </div>
                                </div>
                                <div class="row">
                                    <div class="col-6">
                                        <div class="mb-3">
                                            <div class="metric-label">Cores</div>
                                            <p class="metric-value" id="cpuCores">--</p>
                                        </div>
                                    </div>
                                    <div class="col-6">
                                        <div class="mb-3">
                                            <div class="metric-label">Processes</div>
                                            <p class="metric-value" id="processCount">--</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="mt-2">
                                    <div class="metric-label">Load Averages</div>
                                    <div class="row">
                                        <div class="col-4">
                                            <small class="d-block text-muted">1 min</small>
                                            <span id="loadAvg1m" class="d-block">--</span>
                                        </div>
                                        <div class="col-4">
                                            <small class="d-block text-muted">5 min</small>
                                            <span id="loadAvg5m" class="d-block">--</span>
                                        </div>
                                        <div class="col-4">
                                            <small class="d-block text-muted">15 min</small>
                                            <span id="loadAvg15m" class="d-block">--</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="cpuChart"></canvas>
                        </div>
                        <div class="history-header d-flex align-items-center">
                            <h6 class="mb-0">History Records</h6>
                            <button id="cpuHistoryToggle" class="btn btn-sm btn-link ms-auto">
                                Show more
                                <i class="bi bi-chevron-down"></i>
                            </button>
                        </div>
                        <table class="table table-sm history-table" id="cpuHistoryTable">
                            <thead>
                                <tr>
                                    <th>Timestamp</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody id="cpuHistory">
                                <tr><td colspan="2">No data available</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Memory Metrics -->
            <div class="col-md-6">
                <div class="card metric-card">
                    <div class="metric-card-header">
                        <div>
                            <i class="bi bi-memory"></i> System Memory
                        </div>
                        <div>
                            <span id="memoryAlertBadge" class="badge bg-success">Normal</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="row align-items-center">
                            <div class="col-4 text-center">
                                <div class="circular-progress" id="memoryCircularProgress">
                                    <svg viewBox="0 0 100 100">
                                        <circle class="progress-track" cx="50" cy="50" r="36"></circle>
                                        <circle class="progress-bar progress-bar-memory" cx="50" cy="50" r="36"></circle>
                                    </svg>
                                    <div class="circular-progress-text" id="memoryProgressText">0%</div>
                                </div>
                                <div class="mt-2">
                                    <small class="text-muted">Utilization</small>
                                </div>
                            </div>
                            <div class="col-8">
                                <div class="mb-3">
                                    <div class="d-flex justify-content-between">
                                        <span class="metric-label">Usage</span>
                                        <span class="metric-label" id="memoryUsageLabel">--%</span>
                                    </div>
                                    <div class="progress">
                                        <div id="memoryProgressBar" class="progress-bar progress-bar-memory" role="progressbar" style="width: 0%"></div>
                                    </div>
                                </div>
                                <div class="row">
                                    <div class="col-6">
                                        <div class="mb-2">
                                            <div class="metric-label">Used</div>
                                            <p class="metric-value metric-memory" id="memoryUsed">--</p>
                                        </div>
                                    </div>
                                    <div class="col-6">
                                        <div class="mb-2">
                                            <div class="metric-label">Free</div>
                                            <p class="metric-value metric-memory" id="memoryFree">--</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <div class="metric-label">Total Memory</div>
                                    <p class="metric-value metric-memory" id="memoryTotal">--</p>
                                </div>
                                <div class="mt-1">
                                    <div class="metric-label">Threads</div>
                                    <p id="threadCount" class="mt-1">--</p>
                                </div>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="memoryChart"></canvas>
                        </div>
                        <div class="history-header d-flex align-items-center">
                            <h6 class="mb-0">History Records</h6>
                            <button id="memoryHistoryToggle" class="btn btn-sm btn-link ms-auto">
                                Show more
                                <i class="bi bi-chevron-down"></i>
                            </button>
                        </div>
                        <table class="table table-sm history-table" id="memoryHistoryTable">
                            <thead>
                                <tr>
                                    <th>Timestamp</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody id="memoryHistory">
                                <tr><td colspan="2">No data available</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Storage Metrics -->
            <div class="col-md-6">
                <div class="card metric-card">
                    <div class="metric-card-header">
                        <div>
                            <i class="bi bi-hdd"></i> Storage Disks
                        </div>
                        <div>
                            <span id="storageAlertBadge" class="badge bg-success">Normal</span>
                        </div>
                    </div>
                    <div class="card-body" id="storageDisks">
                        <p>No disk information available</p>
                    </div>
                    <div class="chart-container px-3 pb-3">
                        <canvas id="storageChart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Network Metrics -->
            <div class="col-md-6">
                <div class="card metric-card">
                    <div class="metric-card-header">
                        <div>
                            <i class="bi bi-globe"></i> Network Interfaces
                        </div>
                        <div>
                            <span id="networkAlertBadge" class="badge bg-success">Normal</span>
                        </div>
                    </div>
                    <div class="card-body" id="networkInterfaces">
                        <p>No network interface information available</p>
                    </div>
                    <div class="chart-container px-3 pb-3">
                        <canvas id="networkChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- RTSP Streams -->
            <div class="col-md-12">
                <div class="card metric-card">
                    <div class="metric-card-header">
                        <div>
                            <i class="bi bi-camera-video"></i> RTSP Streams
                        </div>
                        <div>
                            <span id="rtspAlertBadge" class="badge bg-success">All Streams Active</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="row mb-4">
                            <div class="col-md-8">
                                <div class="chart-container" style="height: 250px;">
                                    <canvas id="rtspStatusChart"></canvas>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="status-summary">
                                    <div class="status-item">
                                        <div class="status-label">Active Streams</div>
                                        <div class="status-value text-success" id="activeStreamsCount">0</div>
                                    </div>
                                    <div class="status-item">
                                        <div class="status-label">Failed Streams</div>
                                        <div class="status-value text-danger" id="failedStreamsCount">0</div>
                                    </div>
                                    <div class="status-item">
                                        <div class="status-label">With Video</div>
                                        <div class="status-value" id="streamsWithVideo">0</div>
                                    </div>
                                    <div class="status-item">
                                        <div class="status-label">With Audio</div>
                                        <div class="status-value" id="streamsWithAudio">0</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="table-responsive">
                            <table class="table table-hover">
                                <thead>
                                    <tr>
                                        <th>Stream Name</th>
                                        <th>URL</th>
                                        <th>Status</th>
                                        <th>Video/Audio</th>
                                        <th>Codec Info</th>
                                        <th>Last Checked</th>
                                        <th>Failures</th>
                                        <th>History</th>
                                    </tr>
                                </thead>
                                <tbody id="rtspStreams">
                                    <tr><td colspan="8">No streams found</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Docker Containers -->
            <div class="col-md-12">
                <div class="card metric-card">
                    <div class="metric-card-header">
                        <div>
                            <i class="bi bi-boxes"></i> Docker Containers
                        </div>
                        <div>
                            <span id="dockerAlertBadge" class="badge bg-success">All Healthy</span>
                        </div>
                    </div>
                    <div class="card-body">
                        <div class="row mb-4">
                            <div class="col-md-6">
                                <div class="chart-container" style="height: 200px;">
                                    <canvas id="dockerStatusChart"></canvas>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="chart-container" style="height: 200px;">
                                    <canvas id="dockerResourcesChart"></canvas>
                                </div>
                            </div>
                        </div>
                        <div class="table-responsive">
                            <table class="table table-hover">
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Image</th>
                                        <th>Status</th>
                                        <th>CPU</th>
                                        <th>Memory</th>
                                        <th>Network I/O</th>
                                        <th>Block I/O</th>
                                        <th>PIDs</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="dockerContainers">
                                    <tr><td colspan="9">No containers found</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Stream History Modal -->
    <div class="modal fade" id="streamHistoryModal" tabindex="-1" aria-labelledby="streamHistoryModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header">
                    <h5 class="modal-title" id="streamHistoryModalLabel">Stream History</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="stream-history-chart-container" style="height: 250px;">
                        <canvas id="streamHistoryChart"></canvas>
                    </div>
                    <div class="stream-history-info mt-4">
                        <div class="stream-info-card">
                            <h6>Stream Information</h6>
                            <p id="streamInfoDetails">Loading stream information...</p>
                        </div>
                        <table class="table table-dark table-sm">
                            <thead>
                                <tr>
                                    <th>Time</th>
                                    <th>Status</th>
                                    <th>Message</th>
                                </tr>
                            </thead>
                            <tbody id="streamHistoryTable">
                                <tr><td colspan="3">No history available</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Container Details Modal -->
    <div class="modal fade" id="containerDetailsModal" tabindex="-1" aria-labelledby="containerDetailsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg">
            <div class="modal-content bg-dark text-light">
                <div class="modal-header">
                    <h5 class="modal-title" id="containerDetailsModalLabel">Container Details</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="container-detail-info">
                        <div class="row">
                            <div class="col-md-6">
                                <div class="docker-detail-section">
                                    <h6>Container Information</h6>
                                    <table class="table table-dark table-sm">
                                        <tbody id="containerBasicInfo">
                                            <tr><td>ID</td><td id="detailContainerId">--</td></tr>
                                            <tr><td>Name</td><td id="detailContainerName">--</td></tr>
                                            <tr><td>Image</td><td id="detailContainerImage">--</td></tr>
                                            <tr><td>Status</td><td id="detailContainerStatus">--</td></tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="docker-detail-section">
                                    <h6>Resource Usage</h6>
                                    <table class="table table-dark table-sm">
                                        <tbody id="containerResourceInfo">
                                            <tr><td>CPU</td><td id="detailContainerCpu">--</td></tr>
                                            <tr><td>Memory</td><td id="detailContainerMemory">--</td></tr>
                                            <tr><td>Network I/O</td><td id="detailContainerNetwork">--</td></tr>
                                            <tr><td>Block I/O</td><td id="detailContainerBlockIo">--</td></tr>
                                            <tr><td>PIDs</td><td id="detailContainerPids">--</td></tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <div class="row mt-4">
                            <div class="col-md-6">
                                <h6>CPU Usage History</h6>
                                <div class="small-chart-container">
                                    <canvas id="containerCpuChart"></canvas>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <h6>Memory Usage History</h6>
                                <div class="small-chart-container">
                                    <canvas id="containerMemoryChart"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-outline-light" id="restartContainerBtn">Restart</button>
                    <button type="button" class="btn btn-outline-danger" id="stopContainerBtn">Stop</button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let currentServerId = null;
        let serverList = [];
        let fullHistory = {};
        let rtspStreamHistory = {}; // To track RTSP stream status over time
        let containerHistory = {}; // To track container resource usage over time
        let autoRefreshTimer = null;
        let autoRefreshInterval = 0; // in seconds

        // Chart objects
        let cpuChart = null;
        let memoryChart = null;
        let storageChart = null;
        let networkChart = null;
        let rtspStatusChart = null;
        let dockerStatusChart = null;
        let dockerResourcesChart = null;
        
        // Modal chart objects
        let streamHistoryChart = null;
        let containerCpuChart = null;
        let containerMemoryChart = null;
        
        // Previous values for trend indicators
        let prevCpuValue = null;
        let prevMemoryValue = null;
        
        // Chart color scheme for dark theme
        const chartColors = {
            cpu: 'rgba(77, 166, 255, 0.8)',
            cpuBorder: 'rgba(77, 166, 255, 1)',
            memory: 'rgba(255, 204, 0, 0.8)',
            memoryBorder: 'rgba(255, 204, 0, 1)',
            storage: 'rgba(77, 255, 77, 0.8)',
            storageBorder: 'rgba(77, 255, 77, 1)',
            network: 'rgba(255, 77, 77, 0.8)',
            networkBorder: 'rgba(255, 77, 77, 1)',
            gridLines: 'rgba(100, 100, 100, 0.2)',
            text: 'rgba(224, 224, 224, 1)',
            active: 'rgba(77, 255, 77, 0.8)',
            inactive: 'rgba(255, 77, 77, 0.8)',
            success: 'rgba(77, 255, 77, 1)',
            danger: 'rgba(255, 77, 77, 1)',
            warning: 'rgba(255, 204, 0, 1)',
            info: 'rgba(153, 102, 255, 1)'
        };
        
        // Chart options for dark theme
        const commonChartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: {
                duration: 500
            },
            scales: {
                x: {
                    grid: {
                        color: chartColors.gridLines
                    },
                    ticks: {
                        color: chartColors.text
                    }
                },
                y: {
                    grid: {
                        color: chartColors.gridLines
                    },
                    ticks: {
                        color: chartColors.text
                    }
                }
            },
            plugins: {
                legend: {
                    display: false
                },
                tooltip: {
                    backgroundColor: 'rgba(30, 30, 30, 0.8)',
                    titleColor: '#fff',
                    bodyColor: '#fff',
                    borderColor: 'rgba(77, 166, 255, 0.8)',
                    borderWidth: 1
                }
            },
            elements: {
                point: {
                    radius: 2,
                    hoverRadius: 4
                }
            },
            interaction: {
                mode: 'index',
                intersect: false
            }
        };
        
        // Helper function to nicely format timestamps
        function formatTimestamp(ts) {
            if (!ts) return '--:--:--';
            
            try {
                // Convert to milliseconds if necessary
                if (ts.toString().length === 13) {
                    // Already in milliseconds
                    const d = new Date(Number(ts));
                    if (isNaN(d.getTime())) return ts;
                    return d.toLocaleString(undefined, {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                } else if (ts.toString().length === 10) {
                    // Convert from seconds to milliseconds
                    const d = new Date(Number(ts) * 1000);
                    if (isNaN(d.getTime())) return ts;
                    return d.toLocaleString(undefined, {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                } else {
                    // Try as string
                    const d = new Date(ts);
                    if (isNaN(d.getTime())) return ts;
                    return d.toLocaleString(undefined, {
                        month: 'short',
                        day: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                }
            } catch (e) {
                console.error("Error formatting timestamp:", e);
                return ts;
            }
        }
        
        // Helper function to update circular progress
        function updateCircularProgress(element, value, color) {
            const progressBar = element.querySelector('.progress-bar');
            const progressText = element.querySelector('.circular-progress-text');
            
            if (!progressBar || !progressText) return;
            
            // Calculate the stroke-dashoffset based on the value
            // The circumference of the circle is 2*PI*r = 2*3.14159*36  226.19
            const circumference = 2 * Math.PI * 36;
            const offset = circumference - (value / 100) * circumference;
            
            // Update the stroke-dashoffset property
            progressBar.style.strokeDashoffset = offset;
            
            // Update text and color
            progressText.textContent = `${value.toFixed(1)}%`;
            progressText.style.color = 'white'; // Always use white text
            if (color === 'memory') {
                progressBar.classList.add('progress-bar-memory');
                progressBar.classList.remove('progress-bar');
            } else {
                progressBar.classList.add('progress-bar');
                progressBar.classList.remove('progress-bar-memory');
            }
            
            // Update color based on value
            if (value > 80) {
                progressBar.style.stroke = 'var(--danger-color)';
            } else if (value > 60) {
                progressBar.style.stroke = 'var(--warning-color)';
            } else {
                if (color === 'memory') {
                    progressBar.style.stroke = 'var(--warning-color)';
                } else {
                    progressBar.style.stroke = 'var(--accent-color)';
                }
            }
        }
        
        // Helper function for progress bar state management
        function setProgressBar(barEl, valueNum) {
            barEl.style.width = valueNum + '%';
            
            // Remove any of the three classes first
            barEl.classList.remove('bg-success', 'bg-warning', 'bg-danger');
            
            if (valueNum > 80) {
                barEl.classList.add('bg-danger');
            } else if (valueNum > 60) {
                barEl.classList.add('bg-warning');
            } else {
                barEl.classList.add('bg-success');
            }
        }
        
        // Get trend indicator
        function getTrendIndicator(current, previous) {
            if (previous === null) return '';
            
            // Calculate percentage change
            const change = ((current - previous) / previous) * 100;
            const threshold = 5; // 5% change threshold
            
            if (Math.abs(change) < threshold) {
                return '<i class="bi bi-dash trend-indicator trend-same" title="Stable"></i>';
            } else if (current > previous) {
                return `<i class="bi bi-arrow-up-short trend-indicator trend-up" title="Increasing (${change.toFixed(1)}%)"></i>`;
            } else {
                return `<i class="bi bi-arrow-down-short trend-indicator trend-down" title="Decreasing (${Math.abs(change).toFixed(1)}%)"></i>`;
            }
        }
        
        // Update history tables with all records
        function updateHistoryTable(tableId, historyData) {
            const table = document.getElementById(tableId);
            
            if (!historyData || historyData.length === 0) {
                table.innerHTML = '<tr><td colspan="2">No data available</td></tr>';
                return;
            }
            
            // Save full history in our global object for reference
            fullHistory[tableId] = historyData;
            
            // Sort newest first
            const sorted = [...historyData].sort((a, b) => 
                Number(b.timestamp) - Number(a.timestamp));
            
            // Generate HTML for all rows
            let html = '';
            sorted.forEach(record => {
                html += `<tr>
                    <td>${formatTimestamp(record.timestamp)}</td>
                    <td>${typeof record.value === 'number' ? record.value.toFixed(2) + '%' : record.value}</td>
                </tr>`;
            });
            
            table.innerHTML = html;
            
            // Ensure table starts collapsed
            document.getElementById(tableId + 'Table').classList.remove('expanded');
        }

        // Update system metrics with all the enhancements
        function updateSystemMetrics(systemData) {
            if (!systemData) return;
            
            // CPU section
            const cpuProgressBar = document.getElementById('cpuProgressBar');
            const cpuUsageLabel = document.getElementById('cpuUsageLabel');
            const cpuCircularProgress = document.getElementById('cpuCircularProgress');
            const cpuAlertBadge = document.getElementById('cpuAlertBadge');
            
            // CPU usage
            if (systemData.cpu && systemData.cpu.usage_percent !== undefined) {
                const cpuValueNum = parseFloat(systemData.cpu.usage_percent);
                const cpuValue = cpuValueNum.toFixed(1) + '%';
                
                cpuUsageLabel.textContent = cpuValue;
                document.getElementById('cpuUsageStat').textContent = cpuValue;
                
                // Update circular progress
                updateCircularProgress(cpuCircularProgress, cpuValueNum, 'cpu');
                
                // Update progress bar
                setProgressBar(cpuProgressBar, cpuValueNum);
                
                // Update trend comparison
                const trendIndicator = getTrendIndicator(cpuValueNum, prevCpuValue);
                document.getElementById('cpuUsageStat').innerHTML = cpuValue + trendIndicator;
                prevCpuValue = cpuValueNum;
                
                // Update alert badge
                if (cpuValueNum > 80) {
                    cpuAlertBadge.className = 'badge bg-danger';
                    cpuAlertBadge.textContent = 'Critical';
                } else if (cpuValueNum > 60) {
                    cpuAlertBadge.className = 'badge bg-warning';
                    cpuAlertBadge.textContent = 'High';
                } else {
                    cpuAlertBadge.className = 'badge bg-success';
                    cpuAlertBadge.textContent = 'Normal';
                }
            } else {
                cpuUsageLabel.textContent = '--%';
                cpuProgressBar.style.width = '0%';
                document.getElementById('cpuUsageStat').textContent = '--';
            }
            
            // CPU cores
            const cpuCores = document.getElementById('cpuCores');
            if (systemData.cpu && systemData.cpu.cores !== undefined) {
                cpuCores.textContent = systemData.cpu.cores;
            } else {
                cpuCores.textContent = '--';
            }
            
            // Process count
            const processCount = document.getElementById('processCount');
            if (systemData.processes && systemData.processes.count !== undefined) {
                processCount.textContent = systemData.processes.count;
            } else {
                processCount.textContent = '--';
            }
            
            // Load averages
            const loadAvg1m = document.getElementById('loadAvg1m');
            const loadAvg5m = document.getElementById('loadAvg5m');
            const loadAvg15m = document.getElementById('loadAvg15m');
            
            if (systemData.cpu) {
                if (systemData.cpu.load_avg_1m !== undefined) {
                    loadAvg1m.textContent = parseFloat(systemData.cpu.load_avg_1m).toFixed(2);
                }
                if (systemData.cpu.load_avg_5m !== undefined) {
                    loadAvg5m.textContent = parseFloat(systemData.cpu.load_avg_5m).toFixed(2);
                }
                if (systemData.cpu.load_avg_15m !== undefined) {
                    loadAvg15m.textContent = parseFloat(systemData.cpu.load_avg_15m).toFixed(2);
                }
            }
            
            // Memory section
            const memoryProgressBar = document.getElementById('memoryProgressBar');
            const memoryUsageLabel = document.getElementById('memoryUsageLabel');
            const memoryCircularProgress = document.getElementById('memoryCircularProgress');
            const memoryAlertBadge = document.getElementById('memoryAlertBadge');
            
            // Memory Usage
            if (systemData.memory && systemData.memory.usage_percent !== undefined) {
                const memoryValueNum = parseFloat(systemData.memory.usage_percent);
                const memoryValue = memoryValueNum.toFixed(1) + '%';
                
                memoryUsageLabel.textContent = memoryValue;
                document.getElementById('memoryUsageStat').textContent = memoryValue;
                
                // Update circular progress
                updateCircularProgress(memoryCircularProgress, memoryValueNum, 'memory');
                
                // Update progress bar
                setProgressBar(memoryProgressBar, memoryValueNum);
                
                // Update trend comparison
                const trendIndicator = getTrendIndicator(memoryValueNum, prevMemoryValue);
                document.getElementById('memoryUsageStat').innerHTML = memoryValue + trendIndicator;
                prevMemoryValue = memoryValueNum;
                
                // Update alert badge
                if (memoryValueNum > 80) {
                    memoryAlertBadge.className = 'badge bg-danger';
                    memoryAlertBadge.textContent = 'Critical';
                } else if (memoryValueNum > 60) {
                    memoryAlertBadge.className = 'badge bg-warning';
                    memoryAlertBadge.textContent = 'High';
                } else {
                    memoryAlertBadge.className = 'badge bg-success';
                    memoryAlertBadge.textContent = 'Normal';
                }
            } else {
                memoryUsageLabel.textContent = '--%';
                memoryProgressBar.style.width = '0%';
                document.getElementById('memoryUsageStat').textContent = '--';
            }
            
            // Memory details
            const memoryUsed = document.getElementById('memoryUsed');
            const memoryFree = document.getElementById('memoryFree');
            const memoryTotal = document.getElementById('memoryTotal');
            
            if (systemData.memory) {
                if (systemData.memory.used_mb !== undefined) {
                    memoryUsed.textContent = formatMemory(systemData.memory.used_mb);
                }
                if (systemData.memory.free_mb !== undefined) {
                    memoryFree.textContent = formatMemory(systemData.memory.free_mb);
                }
                if (systemData.memory.total_mb !== undefined) {
                    memoryTotal.textContent = formatMemory(systemData.memory.total_mb);
                }
            }
            
            // Thread count
            const threadCount = document.getElementById('threadCount');
            if (systemData.processes && systemData.processes.threads !== undefined) {
                threadCount.textContent = systemData.processes.threads;
            } else {
                threadCount.textContent = '--';
            }

            // Update system health card based on CPU and memory
            const systemHealthCard = document.getElementById('systemHealthCard');
            const systemHealthStat = document.getElementById('systemHealthStat');
            let cpuStatus = 'good';
            let memoryStatus = 'good';
            
            if (systemData.cpu && systemData.cpu.usage_percent !== undefined) {
                const cpuValue = parseFloat(systemData.cpu.usage_percent);
                if (cpuValue > 80) cpuStatus = 'critical';
                else if (cpuValue > 60) cpuStatus = 'warning';
            }
            
            if (systemData.memory && systemData.memory.usage_percent !== undefined) {
                const memValue = parseFloat(systemData.memory.usage_percent);
                if (memValue > 80) memoryStatus = 'critical';
                else if (memValue > 60) memoryStatus = 'warning';
            }
            
            // Overall health status
            if (cpuStatus === 'critical' || memoryStatus === 'critical') {
                systemHealthCard.className = 'stat-card stat-red';
                systemHealthStat.textContent = 'Critical';
            } else if (cpuStatus === 'warning' || memoryStatus === 'warning') {
                systemHealthCard.className = 'stat-card stat-yellow';
                systemHealthStat.textContent = 'Warning';
            } else {
                systemHealthCard.className = 'stat-card stat-green';
                systemHealthStat.textContent = 'Good';
            }
        }
        
        // Helper function to format memory values
        function formatMemory(mbValue) {
            const mb = parseFloat(mbValue);
            if (isNaN(mb)) return mbValue;
            
            if (mb >= 1024) {
                return (mb / 1024).toFixed(2) + ' GB';
            } else {
                return mb.toFixed(0) + ' MB';
            }
        }
        
        // Update RTSP stream metrics
        function updateRtspMetrics(rtspData) {
            if (!rtspData || !rtspData.streams) return;
            
            const streamsTable = document.getElementById('rtspStreams');
            const streams = rtspData.streams;
            const rtspAlertBadge = document.getElementById('rtspAlertBadge');
            
            if (Object.keys(streams).length === 0) {
                streamsTable.innerHTML = '<tr><td colspan="8">No streams found</td></tr>';
                return;
            }
            
            // Create an array to store stream status history
            const currentTime = new Date().getTime();
            const streamStates = [];
            
            let html = '';
            let activeCount = 0;
            let failedCount = 0;
            let withVideoCount = 0;
            let withAudioCount = 0;
            
            for (const streamId in streams) {
                const stream = streams[streamId];
                
                // Initialize history for this stream if not exists
                if (!rtspStreamHistory[streamId]) {
                    rtspStreamHistory[streamId] = [];
                }
                
                // Fix status detection - consider streams with video as active
                const hasVideo = stream.has_video === true;
                const hasAudio = stream.has_audio === true;
                
                if (hasVideo) withVideoCount++;
                if (hasAudio) withAudioCount++;
                
                // Consider stream active if it has video or if status is explicitly 'active'
                const isActive = hasVideo || stream.active === true;
                
                // Track active/failed counts
                if (isActive) {
                    activeCount++;
                    // Add status to history
                    rtspStreamHistory[streamId].push({
                        timestamp: currentTime,
                        status: 'active',
                        hasVideo: hasVideo,
                        hasAudio: hasAudio
                    });
                } else {
                    failedCount++;
                    // Add status to history
                    rtspStreamHistory[streamId].push({
                        timestamp: currentTime,
                        status: 'inactive',
                        hasVideo: hasVideo,
                        hasAudio: hasAudio,
                        error: stream.error_message
                    });
                }
                
                // Keep only the last 100 history entries
                if (rtspStreamHistory[streamId].length > 100) {
                    rtspStreamHistory[streamId] = rtspStreamHistory[streamId].slice(-100);
                }
                
                // Store current stream state for chart
                streamStates.push({
                    id: streamId,
                    name: stream.stream_name || streamId,
                    active: isActive
                });
                
                const statusClass = isActive ? 'stream-active' : 'stream-inactive';
                const statusText = isActive ? 'Active' : 'Inactive';
                const videoIcon = hasVideo ? '<i class="bi bi-camera-video-fill icon-available"></i>' : '<i class="bi bi-camera-video-off icon-unavailable"></i>';
                const audioIcon = hasAudio ? '<i class="bi bi-mic-fill icon-available"></i>' : '<i class="bi bi-mic-mute icon-unavailable"></i>';
                
                // Format timestamp if it's a number
                let lastChecked = formatTimestamp(stream.last_checked || '--');
                
                html += `<tr>
                    <td>${stream.stream_name || streamId}</td>
                    <td><small>${stream.stream_url || '--'}</small></td>
                    <td><span class="${statusClass}">${statusText}</span></td>
                    <td>${videoIcon} Video<br>${audioIcon} Audio</td>
                    <td>${stream.codec_type || '--'}</td>
                    <td>${lastChecked}</td>
                    <td>${stream.consecutive_failures || '0'}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-info view-stream-history" data-stream-id="${streamId}">
                            <i class="bi bi-clock-history"></i>
                        </button>
                    </td>
                </tr>`;
                
                if (!isActive && stream.error_message) {
                    html += `<tr>
                        <td colspan="8" class="text-danger"><small>Error: ${stream.error_message}</small></td>
                    </tr>`;
                }
            }
            
            streamsTable.innerHTML = html;
            
            // Update summary counters
            document.getElementById('activeStreamsCount').textContent = activeCount;
            document.getElementById('failedStreamsCount').textContent = failedCount;
            document.getElementById('streamsWithVideo').textContent = withVideoCount;
            document.getElementById('streamsWithAudio').textContent = withAudioCount;
            document.getElementById('activeStreamsStat').textContent = activeCount;
            document.getElementById('failedStreamsStat').textContent = failedCount;
            
            // Update alert badge
            if (failedCount > 0) {
                if (activeCount === 0) {
                    rtspAlertBadge.className = 'badge bg-danger';
                    rtspAlertBadge.textContent = 'All Streams Failed';
                } else {
                    rtspAlertBadge.className = 'badge bg-warning';
                    rtspAlertBadge.textContent = failedCount + ' Failed Streams';
                }
            } else {
                rtspAlertBadge.className = 'badge bg-success';
                rtspAlertBadge.textContent = 'All Streams Active';
            }
            
            // Update RTSP Status Chart
            updateRtspStatusChart(streamStates);
            
            // Add click event to view history buttons
            document.querySelectorAll('.view-stream-history').forEach(btn => {
                btn.addEventListener('click', function() {
                    const streamId = this.getAttribute('data-stream-id');
                    showStreamHistory(streamId, streams[streamId]);
                });
            });
        }
        
        // Show stream history
        function showStreamHistory(streamId, streamInfo) {
            const modal = new bootstrap.Modal(document.getElementById('streamHistoryModal'));
            document.getElementById('streamHistoryModalLabel').textContent = `Stream History: ${streamInfo.stream_name || streamId}`;
            document.getElementById('streamInfoDetails').innerHTML = `
                <strong>Stream URL:</strong> ${streamInfo.stream_url || 'N/A'}<br>
                <strong>Status:</strong> ${streamInfo.active ? 'Active' : 'Inactive'}<br>
                <strong>Video:</strong> ${streamInfo.has_video ? 'Yes' : 'No'}<br>
                <strong>Audio:</strong> ${streamInfo.has_audio ? 'Yes' : 'No'}<br>
                <strong>Codec:</strong> ${streamInfo.codec_type || 'N/A'}<br>
                <strong>Last Checked:</strong> ${formatTimestamp(streamInfo.last_checked) || 'N/A'}<br>
                <strong>Consecutive Failures:</strong> ${streamInfo.consecutive_failures || '0'}<br>
                ${streamInfo.error_message ? '<strong>Last Error:</strong> ' + streamInfo.error_message : ''}
            `;
            
            // Update history table
            const historyTable = document.getElementById('streamHistoryTable');
            const history = rtspStreamHistory[streamId] || [];
            
            if (history.length === 0) {
                historyTable.innerHTML = '<tr><td colspan="3">No history available</td></tr>';
            } else {
                let html = '';
                [...history].reverse().forEach(entry => {
                    const statusClass = entry.status === 'active' ? 'text-success' : 'text-danger';
                    const statusText = entry.status === 'active' ? 'Active' : 'Inactive';
                    
                    html += `<tr>
                        <td>${formatTimestamp(entry.timestamp)}</td>
                        <td class="${statusClass}">${statusText}</td>
                        <td>${entry.error || '-'}</td>
                    </tr>`;
                });
                historyTable.innerHTML = html;
            }
            
            // Update history chart
            updateStreamHistoryChart(streamId);
            
            modal.show();
        }
        
        // Update stream history chart
        function updateStreamHistoryChart(streamId) {
            const ctx = document.getElementById('streamHistoryChart').getContext('2d');
            const history = rtspStreamHistory[streamId] || [];
            
            if (streamHistoryChart) {
                streamHistoryChart.destroy();
            }
            
            // Prepare data
            const labels = history.map(entry => new Date(entry.timestamp));
            const data = history.map(entry => entry.status === 'active' ? 1 : 0);
            
            streamHistoryChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Status (1=Active, 0=Inactive)',
                        data: data,
                        backgroundColor: 'rgba(77, 255, 77, 0.2)',
                        borderColor: 'rgba(77, 255, 77, 1)',
                        borderWidth: 2,
                        pointRadius: 3,
                        pointBackgroundColor: function(context) {
                            const value = context.dataset.data[context.dataIndex];
                            return value === 1 ? 'rgba(77, 255, 77, 1)' : 'rgba(255, 77, 77, 1)';
                        },
                        pointBorderColor: function(context) {
                            const value = context.dataset.data[context.dataIndex];
                            return value === 1 ? 'rgba(77, 255, 77, 1)' : 'rgba(255, 77, 77, 1)';
                        },
                        steppedLine: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm:ss'
                                }
                            },
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                color: chartColors.text
                            }
                        },
                        y: {
                            min: -0.1,
                            max: 1.1,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    if (value === 0) return 'Inactive';
                                    if (value === 1) return 'Active';
                                    return '';
                                },
                                color: chartColors.text
                            },
                            grid: {
                                color: chartColors.gridLines
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.y;
                                    return value === 1 ? 'Active' : 'Inactive';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update RTSP Status Chart
        function updateRtspStatusChart(streamStates) {
            const ctx = document.getElementById('rtspStatusChart').getContext('2d');
            
            if (rtspStatusChart) {
                rtspStatusChart.destroy();
            }
            
            // Calculate active vs inactive count
            const activeCount = streamStates.filter(s => s.active).length;
            const inactiveCount = streamStates.length - activeCount;
            
            rtspStatusChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: streamStates.map(s => s.name),
                    datasets: [
                        {
                            label: 'Stream Status',
                            data: streamStates.map(s => s.active ? 1 : 0),
                            backgroundColor: streamStates.map(s => s.active ? chartColors.active : chartColors.inactive),
                            borderColor: streamStates.map(s => s.active ? chartColors.success : chartColors.danger),
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    scales: {
                        x: {
                            min: 0,
                            max: 1,
                            ticks: {
                                stepSize: 1,
                                callback: function(value) {
                                    if (value === 0) return 'Inactive';
                                    if (value === 1) return 'Active';
                                    return '';
                                },
                                color: chartColors.text
                            },
                            grid: {
                                color: chartColors.gridLines
                            }
                        },
                        y: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: chartColors.text
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.parsed.x;
                                    return value === 1 ? 'Status: Active' : 'Status: Inactive';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update Docker container metrics
        function updateDockerMetrics(dockerData) {
            if (!dockerData || !dockerData.containers) return;
            
            const containersTable = document.getElementById('dockerContainers');
            const containers = dockerData.containers;
            const dockerAlertBadge = document.getElementById('dockerAlertBadge');
            
            if (Object.keys(containers).length === 0) {
                containersTable.innerHTML = '<tr><td colspan="9">No containers found</td></tr>';
                return;
            }
            
            // Container stats for charts
            const statusCounts = {
                running: 0,
                stopped: 0,
                paused: 0,
                dead: 0
            };
            
            const resourcesData = {
                names: [],
                cpu: [],
                memory: []
            };
            
            let html = '';
            for (const containerId in containers) {
                const container = containers[containerId];
                const info = container.info || {};
                const stats = container.stats || {};
                
                // Track status for chart
                const status = info.simple_status || 'unknown';
                if (status === 'running') statusCounts.running++;
                else if (status === 'stopped') statusCounts.stopped++;
                else if (status === 'paused') statusCounts.paused++;
                else statusCounts.dead++;
                
                // Add to resources chart if running
                if (status === 'running') {
                    resourcesData.names.push(info.name || containerId.substring(0, 8));
                    resourcesData.cpu.push(parseFloat(stats.cpu_percent || 0));
                    resourcesData.memory.push(parseFloat(stats.memory_percent || 0));
                }
                
                // Add to container history
                if (!containerHistory[containerId]) {
                    containerHistory[containerId] = {
                        cpu: [],
                        memory: [],
                        network: [],
                        info: []
                    };
                }
                
                // Add current stats to history
                const currentTime = new Date().getTime();
                if (stats.cpu_percent) {
                    containerHistory[containerId].cpu.push({
                        timestamp: currentTime,
                        value: parseFloat(stats.cpu_percent)
                    });
                }
                
                if (stats.memory_percent) {
                    containerHistory[containerId].memory.push({
                        timestamp: currentTime,
                        value: parseFloat(stats.memory_percent)
                    });
                }
                
                // Keep history size manageable
                if (containerHistory[containerId].cpu.length > 100) {
                    containerHistory[containerId].cpu = containerHistory[containerId].cpu.slice(-100);
                }
                
                if (containerHistory[containerId].memory.length > 100) {
                    containerHistory[containerId].memory = containerHistory[containerId].memory.slice(-100);
                }
                
                // Add container info history
                containerHistory[containerId].info.push({
                    timestamp: currentTime,
                    status: info.status || 'unknown',
                    simple_status: info.simple_status || 'unknown'
                });
                
                if (containerHistory[containerId].info.length > 100) {
                    containerHistory[containerId].info = containerHistory[containerId].info.slice(-100);
                }
                
                const statusBadgeClass = info.simple_status === 'running' ? 'bg-success' : 'bg-danger';
                
                html += `<tr class="container-row" data-container-id="${containerId}">
                    <td>${info.name || containerId}</td>
                    <td>${info.image || '--'}</td>
                    <td><span class="badge ${statusBadgeClass}">${info.status || 'unknown'}</span></td>
                    <td>${stats.cpu_percent || '--'}%</td>
                    <td>${stats.memory_percent || '--'}% <br>(${stats.memory_used || '--'})</td>
                    <td>${stats.net_io || '--'}</td>
                    <td>${stats.block_io || '--'}</td>
                    <td>${stats.pids || '--'}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-info view-container-details" data-container-id="${containerId}">
                            <i class="bi bi-info-circle"></i>
                        </button>
                    </td>
                </tr>`;
            }
            
            containersTable.innerHTML = html;
            
            // Update Docker status charts
            updateDockerStatusChart(statusCounts);
            updateDockerResourcesChart(resourcesData);
            
            // Update stats
            document.getElementById('runningContainersStat').textContent = statusCounts.running;
            
            // Update alert badge
            if (statusCounts.running === 0) {
                dockerAlertBadge.className = 'badge bg-danger';
                dockerAlertBadge.textContent = 'All Containers Stopped';
            } else if (statusCounts.stopped > 0 || statusCounts.dead > 0) {
                dockerAlertBadge.className = 'badge bg-warning';
                dockerAlertBadge.textContent = 'Some Containers Stopped';
            } else {
                dockerAlertBadge.className = 'badge bg-success';
                dockerAlertBadge.textContent = 'All Containers Running';
            }
            
            // Add click event for container details
            document.querySelectorAll('.view-container-details').forEach(btn => {
                btn.addEventListener('click', function() {
                    const containerId = this.getAttribute('data-container-id');
                    showContainerDetails(containerId, containers[containerId]);
                });
            });
        }
        
        // Show container details modal
        function showContainerDetails(containerId, containerData) {
            const modal = new bootstrap.Modal(document.getElementById('containerDetailsModal'));
            const info = containerData.info || {};
            const stats = containerData.stats || {};
            
            // Set modal title
            document.getElementById('containerDetailsModalLabel').textContent = `Container Details: ${info.name || containerId}`;
            
            // Set basic info
            document.getElementById('detailContainerId').textContent = containerId;
            document.getElementById('detailContainerName').textContent = info.name || '--';
            document.getElementById('detailContainerImage').textContent = info.image || '--';
            document.getElementById('detailContainerStatus').textContent = info.status || '--';
            
            // Set resource info
            document.getElementById('detailContainerCpu').textContent = stats.cpu_percent || '--';
            document.getElementById('detailContainerMemory').textContent = 
                `${stats.memory_percent || '--'}% (${stats.memory_used || '--'} / ${stats.memory_limit || '--'})`;
            document.getElementById('detailContainerNetwork').textContent = stats.net_io || '--';
            document.getElementById('detailContainerBlockIo').textContent = stats.block_io || '--';
            document.getElementById('detailContainerPids').textContent = stats.pids || '--';
            
            // Setup charts for CPU and memory history
            updateContainerCharts(containerId);
            
            // Setup action buttons
            document.getElementById('restartContainerBtn').onclick = function() {
                // This would call a restart API in a real implementation
                alert('This would restart container ' + containerId);
            };
            
            document.getElementById('stopContainerBtn').onclick = function() {
                // This would call a stop API in a real implementation
                alert('This would stop container ' + containerId);
            };
            
            modal.show();
        }
        
        // Update container history charts
        function updateContainerCharts(containerId) {
            const cpuCtx = document.getElementById('containerCpuChart').getContext('2d');
            const memoryCtx = document.getElementById('containerMemoryChart').getContext('2d');
            const history = containerHistory[containerId] || { cpu: [], memory: [] };
            
            // Clear existing charts
            if (containerCpuChart) containerCpuChart.destroy();
            if (containerMemoryChart) containerMemoryChart.destroy();
            
            // CPU Chart
            containerCpuChart = new Chart(cpuCtx, {
                type: 'line',
                data: {
                    labels: history.cpu.map(item => new Date(item.timestamp)),
                    datasets: [{
                        label: 'CPU Usage %',
                        data: history.cpu.map(item => item.value),
                        backgroundColor: 'rgba(77, 166, 255, 0.2)',
                        borderColor: 'rgba(77, 166, 255, 1)',
                        borderWidth: 2,
                        tension: 0.2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm:ss'
                                }
                            },
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                color: chartColors.text
                            }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                },
                                color: chartColors.text
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
            
            // Memory Chart
            containerMemoryChart = new Chart(memoryCtx, {
                type: 'line',
                data: {
                    labels: history.memory.map(item => new Date(item.timestamp)),
                    datasets: [{
                        label: 'Memory Usage %',
                        data: history.memory.map(item => item.value),
                        backgroundColor: 'rgba(255, 204, 0, 0.2)',
                        borderColor: 'rgba(255, 204, 0, 1)',
                        borderWidth: 2,
                        tension: 0.2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm:ss'
                                }
                            },
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                color: chartColors.text
                            }
                        },
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                },
                                color: chartColors.text
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        }
                    }
                }
            });
        }
        
        // Update Docker status chart
        function updateDockerStatusChart(statusCounts) {
            const ctx = document.getElementById('dockerStatusChart').getContext('2d');
            
            if (dockerStatusChart) {
                dockerStatusChart.destroy();
            }
            
            dockerStatusChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Running', 'Stopped', 'Paused', 'Dead'],
                    datasets: [{
                        data: [
                            statusCounts.running,
                            statusCounts.stopped,
                            statusCounts.paused,
                            statusCounts.dead
                        ],
                        backgroundColor: [
                            chartColors.success,
                            chartColors.danger,
                            chartColors.warning,
                            '#777777'
                        ],
                        borderColor: [
                            'rgba(77, 255, 77, 1)',
                            'rgba(255, 77, 77, 1)',
                            'rgba(255, 204, 0, 1)',
                            '#555555'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '60%',
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: chartColors.text,
                                padding: 10
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.parsed || 0;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = total > 0 ? Math.round((value / total) * 100) : 0;
                                    return `${label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update Docker resources chart
        function updateDockerResourcesChart(resourcesData) {
            const ctx = document.getElementById('dockerResourcesChart').getContext('2d');
            
            if (dockerResourcesChart) {
                dockerResourcesChart.destroy();
            }
            
            dockerResourcesChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: resourcesData.names,
                    datasets: [
                        {
                            label: 'CPU Usage %',
                            data: resourcesData.cpu,
                            backgroundColor: 'rgba(77, 166, 255, 0.7)',
                            borderColor: 'rgba(77, 166, 255, 1)',
                            borderWidth: 1,
                            order: 1
                        },
                        {
                            label: 'Memory Usage %',
                            data: resourcesData.memory,
                            backgroundColor: 'rgba(255, 204, 0, 0.7)',
                            borderColor: 'rgba(255, 204, 0, 1)',
                            borderWidth: 1,
                            order: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                },
                                color: chartColors.text
                            },
                            stacked: false
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: chartColors.text
                            },
                            stacked: false
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: chartColors.text
                            }
                        }
                    }
                }
            });
        }
        
        // Update storage metrics
        function updateStorageMetrics(storageData) {
            if (!storageData || !storageData.disks) return;
            
            const disksDiv = document.getElementById('storageDisks');
            const disks = storageData.disks;
            const storageAlertBadge = document.getElementById('storageAlertBadge');
            
            if (Object.keys(disks).length === 0) {
                disksDiv.innerHTML = '<p>No disk information available</p>';
                return;
            }
            
            let html = '<div class="table-responsive"><table class="table table-sm">' +
                      '<thead><tr><th>Mount</th><th>Usage</th><th>Free</th><th>Total</th><th>Filesystem</th></tr></thead>' +
                      '<tbody>';
                      
            // For storage chart
            const diskLabels = [];
            const diskUsageData = [];
            
            // For critical storage alert
            let criticalDisks = 0;
            let warningDisks = 0;
            
            for (const mountPoint in disks) {
                const disk = disks[mountPoint];
                const usagePercent = parseFloat(disk.usage_percent) || 0;
                
                // Skip system volumes with very small sizes (less than 1GB)
                if (parseFloat(disk.total_gb) < 1) continue;
                
                // Used for chart
                const diskName = disk.name || mountPoint;
                diskLabels.push(diskName.length > 15 ? diskName.substring(0, 12) + '...' : diskName);
                diskUsageData.push(usagePercent);
                
                // Track alert status
                if (usagePercent > 90) criticalDisks++;
                else if (usagePercent > 75) warningDisks++;
                
                const progressBarClass = usagePercent > 90 ? 'bg-danger' : 
                                        usagePercent > 75 ? 'bg-warning' : 
                                        'bg-success';
                
                html += `<tr>
                    <td title="${mountPoint}">${disk.name || mountPoint}</td>
                    <td>
                        <div class="progress">
                            <div class="progress-bar ${progressBarClass}" role="progressbar" style="width: ${usagePercent}%" aria-valuenow="${usagePercent}" aria-valuemin="0" aria-valuemax="100"></div>
                        </div>
                        <small>${usagePercent.toFixed(1)}%</small>
                    </td>
                    <td>${disk.free_gb || '--'} GB</td>
                    <td>${disk.total_gb || '--'} GB</td>
                    <td>${disk.filesystem || '--'}</td>
                </tr>`;
            }
            
            html += '</tbody></table></div>';
            disksDiv.innerHTML = html;
            
            // Update storage chart
            if (storageChart && diskLabels.length > 0) {
                storageChart.data.labels = diskLabels;
                storageChart.data.datasets[0].data = diskUsageData;
                storageChart.update();
            }
            
            // Update alert badge
            if (criticalDisks > 0) {
                storageAlertBadge.className = 'badge bg-danger';
                storageAlertBadge.textContent = criticalDisks === 1 ? '1 Critical Disk' : criticalDisks + ' Critical Disks';
            } else if (warningDisks > 0) {
                storageAlertBadge.className = 'badge bg-warning';
                storageAlertBadge.textContent = warningDisks === 1 ? '1 Warning Disk' : warningDisks + ' Warning Disks';
            } else {
                storageAlertBadge.className = 'badge bg-success';
                storageAlertBadge.textContent = 'Normal';
            }
        }
        
        // Update network metrics
        function updateNetworkMetrics(networkData) {
            if (!networkData || !networkData.interfaces) return;
            
            const interfacesDiv = document.getElementById('networkInterfaces');
            const interfaces = networkData.interfaces;
            const networkAlertBadge = document.getElementById('networkAlertBadge');
            
            if (Object.keys(interfaces).length === 0) {
                interfacesDiv.innerHTML = '<p>No network interface information available</p>';
                return;
            }
            
            let html = '<div class="table-responsive"><table class="table table-sm">' +
                     '<thead><tr><th>Interface</th><th>Status</th><th>IP Address</th><th>Received</th><th>Sent</th><th>Rate</th></tr></thead>' +
                     '<tbody>';
            
            // For network chart
            const interfaceLabels = [];
            const receivedData = [];
            const sentData = [];
            
            // Track traffic rates for alerts
            let highTrafficInterfaces = 0;
            
            for (const interfaceName in interfaces) {
                const iface = interfaces[interfaceName];
                
                // Skip interfaces with no activity
                if (parseFloat(iface.received_mb) < 0.1 && parseFloat(iface.sent_mb) < 0.1) continue;
                
                // Calculate traffic rate in Mbps
                const receivedRate = parseFloat(iface.received_rate_kbps) / 1000 || 0;
                const sentRate = parseFloat(iface.sent_rate_kbps) / 1000 || 0;
                const totalRate = receivedRate + sentRate;
                
                // Track high traffic interfaces
                if (totalRate > 50) highTrafficInterfaces++;
                
                // Only include main interfaces in chart
                if (parseFloat(iface.received_mb) > 1 || parseFloat(iface.sent_mb) > 1) {
                    interfaceLabels.push(iface.name || interfaceName);
                    receivedData.push(parseFloat(iface.received_mb) || 0);
                    sentData.push(parseFloat(iface.sent_mb) || 0);
                }
                
                const statusClass = iface.status === 'UP' ? 'text-success' : 'text-secondary';
                const statusText = iface.status || 'UNKNOWN';
                
                html += `<tr>
                    <td>${iface.name || interfaceName}</td>
                    <td class="${statusClass}"><i class="bi bi-circle-fill me-1"></i>${statusText}</td>
                    <td>${iface.ip_address || '--'}</td>
                    <td>${parseFloat(iface.received_mb).toFixed(2)} MB</td>
                    <td>${parseFloat(iface.sent_mb).toFixed(2)} MB</td>
                    <td> ${receivedRate.toFixed(2)} Mbps<br> ${sentRate.toFixed(2)} Mbps</td>
                </tr>`;
            }
            
            html += '</tbody></table></div>';
            interfacesDiv.innerHTML = html;
            
            // Update network chart
            if (networkChart && interfaceLabels.length > 0) {
                networkChart.data.labels = interfaceLabels;
                networkChart.data.datasets[0].data = receivedData;
                networkChart.data.datasets[1].data = sentData;
                networkChart.update();
            }
            
            // Update alert badge
            if (highTrafficInterfaces > 0) {
                networkAlertBadge.className = 'badge bg-warning';
                networkAlertBadge.textContent = 'High Traffic';
            } else {
                networkAlertBadge.className = 'badge bg-success';
                networkAlertBadge.textContent = 'Normal';
            }
        }
        
        // Update charts with historical data
        function updateCharts(historyData) {
            if (historyData.cpu && historyData.cpu.length > 0) {
                // Sort by timestamp
                const sorted = historyData.cpu.sort((a, b) => Number(a.timestamp) - Number(b.timestamp));
                
                const labels = sorted.map(entry => new Date(Number(entry.timestamp)));
                const cpuData = sorted.map(entry => typeof entry.value === 'number' ? entry.value : 0);
                
                if (cpuChart) {
                    cpuChart.data.labels = labels;
                    cpuChart.data.datasets[0].data = cpuData;
                    cpuChart.update();
                }
            }
            
            if (historyData.memory && historyData.memory.length > 0) {
                // Sort by timestamp
                const sorted = historyData.memory.sort((a, b) => Number(a.timestamp) - Number(b.timestamp));
                
                const labels = sorted.map(entry => new Date(Number(entry.timestamp)));
                const memoryData = sorted.map(entry => typeof entry.value === 'number' ? entry.value : 0);
                
                if (memoryChart) {
                    memoryChart.data.labels = labels;
                    memoryChart.data.datasets[0].data = memoryData;
                    memoryChart.update();
                }
            }
        }
        
        // Update server info
        function updateServerInfo(serverData) {
            if (!serverData) return;
            
            document.getElementById('serverName').textContent = serverData.name || serverData.hostname || 'Unknown Server';
            document.getElementById('serverLocation').textContent = 'Location: ' + (serverData.location || 'Unknown');
            document.getElementById('serverId').textContent = 'ID: ' + (serverData.id || 'Unknown');
            document.getElementById('serverOs').textContent = 'OS: ' + (serverData.os_name || 'Unknown');
        }
        
        // Initialize charts
        function initCharts() {
            // CPU Chart
            const cpuCtx = document.getElementById('cpuChart').getContext('2d');
            cpuChart = new Chart(cpuCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'CPU Usage %',
                        data: [],
                        borderColor: chartColors.cpuBorder,
                        backgroundColor: 'rgba(77, 166, 255, 0.2)',
                        fill: true,
                        tension: 0.4,
                        borderWidth: 2,
                        pointRadius: 3,
                        pointBackgroundColor: chartColors.cpuBorder
                    }]
                },
                options: {
                    ...commonChartOptions,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(30, 30, 30, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: 'rgba(77, 166, 255, 0.8)',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return 'CPU: ' + context.parsed.y.toFixed(2) + '%';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: 100,
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                },
                                color: chartColors.text
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm:ss'
                                }
                            },
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                maxRotation: 0,
                                color: chartColors.text
                            }
                        }
                    }
                }
            });
            
            // Memory Chart
            const memoryCtx = document.getElementById('memoryChart').getContext('2d');
            memoryChart = new Chart(memoryCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Memory Usage %',
                        data: [],
                        borderColor: chartColors.memoryBorder,
                        backgroundColor: 'rgba(255, 204, 0, 0.2)',
                        fill: true,
                        tension: 0.4,
                        borderWidth: 2,
                        pointRadius: 3,
                        pointBackgroundColor: chartColors.memoryBorder
                    }]
                },
                options: {
                    ...commonChartOptions,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            backgroundColor: 'rgba(30, 30, 30, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: 'rgba(255, 204, 0, 0.8)',
                            borderWidth: 1,
                            callbacks: {
                                label: function(context) {
                                    return 'Memory: ' + context.parsed.y.toFixed(2) + '%';
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: 100,
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                },
                                color: chartColors.text
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm:ss'
                                }
                            },
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                maxRotation: 0,
                                color: chartColors.text
                            }
                        }
                    }
                }
            });
            
            // Storage Chart
            const storageCtx = document.getElementById('storageChart').getContext('2d');
            storageChart = new Chart(storageCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Disk Usage %',
                        data: [],
                        backgroundColor: chartColors.storage,
                        borderColor: chartColors.storageBorder,
                        borderWidth: 1,
                        borderRadius: 5,
                        maxBarThickness: 30
                    }]
                },
                options: {
                    ...commonChartOptions,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return 'Usage: ' + context.parsed.y.toFixed(1) + '%';
                                }
                            },
                            backgroundColor: 'rgba(30, 30, 30, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: 'rgba(77, 255, 77, 0.8)',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                },
                                color: chartColors.text
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: chartColors.text
                            }
                        }
                    }
                }
            });
            
            // Network Chart
            const networkCtx = document.getElementById('networkChart').getContext('2d');
            networkChart = new Chart(networkCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'Received (MB)',
                            data: [],
                            backgroundColor: 'rgba(77, 166, 255, 0.7)',
                            borderColor: 'rgba(77, 166, 255, 1)',
                            borderWidth: 1,
                            borderRadius: 5,
                            maxBarThickness: 20
                        },
                        {
                            label: 'Sent (MB)',
                            data: [],
                            backgroundColor: 'rgba(255, 77, 77, 0.7)',
                            borderColor: 'rgba(255, 77, 77, 1)',
                            borderWidth: 1,
                            borderRadius: 5,
                            maxBarThickness: 20
                        }
                    ]
                },
                options: {
                    ...commonChartOptions,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: chartColors.text,
                                boxWidth: 12,
                                padding: 10
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + context.parsed.y.toFixed(2) + ' MB';
                                }
                            },
                            backgroundColor: 'rgba(30, 30, 30, 0.8)',
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            borderColor: 'rgba(77, 166, 255, 0.8)',
                            borderWidth: 1
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: chartColors.gridLines
                            },
                            ticks: {
                                color: chartColors.text
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                color: chartColors.text
                            }
                        }
                    }
                }
            });
        }
        
        // Update dashboard clock
        function updateClock() {
            const now = new Date();
            const clockDisplay = document.getElementById('clockDisplay');
            
            clockDisplay.textContent = now.toLocaleString(undefined, {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
        }
        
        // Set up auto-refresh functionality
        function setupAutoRefresh() {
            document.querySelectorAll('.refresh-option').forEach(option => {
                option.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    const seconds = parseInt(this.getAttribute('data-seconds'));
                    const refreshIntervalBtn = document.getElementById('refreshInterval');
                    
                    // Clear existing timer
                    if (autoRefreshTimer) {
                        clearInterval(autoRefreshTimer);
                    }
                    
                    // Set new interval
                    autoRefreshInterval = seconds;
                    refreshIntervalBtn.setAttribute('data-interval', seconds);
                    
                    if (seconds > 0) {
                        refreshIntervalBtn.textContent = `Auto-refresh: ${seconds}s`;
                        refreshIntervalBtn.classList.add('btn-primary');
                        refreshIntervalBtn.classList.remove('btn-outline-light');
                        
                        // Start timer
                        autoRefreshTimer = setInterval(function() {
                            fetchData();
                        }, seconds * 1000);
                    } else {
                        refreshIntervalBtn.textContent = 'Auto-refresh: Off';
                        refreshIntervalBtn.classList.remove('btn-primary');
                        refreshIntervalBtn.classList.add('btn-outline-light');
                    }
                });
            });
            
            // Toggle button handler
            document.getElementById('refreshInterval').addEventListener('click', function() {
                const currentInterval = parseInt(this.getAttribute('data-interval'));
                
                // Toggle between off and 10 seconds
                const newInterval = currentInterval > 0 ? 0 : 10;
                
                // Trigger the appropriate refresh option
                document.querySelector(`.refresh-option[data-seconds="${newInterval}"]`).click();
            });
        }

        // Fetch server list
        function fetchServerList() {
            // Use the API endpoint from MetricsController
            return fetch('/api/metrics/servers')
                .then(response => response.json())
                .then(data => {
                    serverList = data;
                    
                    const selector = document.getElementById('serverSelector');
                    
                    if (serverList.length === 0) {
                        selector.innerHTML = '<option value="">No servers found</option>';
                        return Promise.resolve();
                    }
                    
                    let options = '<option value="">Select a server</option>';
                    serverList.forEach(server => {
                        options += `<option value="${server.id}">${server.name || server.hostname || server.id}</option>`;
                    });
                    
                    selector.innerHTML = options;
                    
                    // If only one server, select it automatically
                    if (serverList.length === 1) {
                        selector.value = serverList[0].id;
                        currentServerId = serverList[0].id;
                        return fetchServerData(currentServerId);
                    } else {
                        return Promise.resolve();
                    }
                })
                .catch(error => {
                    console.error('Error fetching server list:', error);
                    document.getElementById('serverSelector').innerHTML = '<option value="">Error loading servers</option>';
                    return Promise.reject(error);
                });
        }
        
        // Fetch server data
        function fetchServerData(serverId) {
            if (!serverId) {
                return Promise.reject(new Error('No server ID provided'));
            }
            
            // Fetch data from the API endpoint in MetricsController
            return fetch(`/api/metrics/server/${serverId}`)
                .then(response => response.json())
                .then(data => {
                    // Update all components with data from API
                    updateServerInfo(data.server_info);
                    updateSystemMetrics(data.system);
                    updateDockerMetrics(data.docker);
                    updateStorageMetrics(data.storage);
                    updateNetworkMetrics(data.network);
                    updateRtspMetrics(data.rtsp);
                    
                    if (data.history) {
                        updateHistoryTable('cpuHistory', data.history.cpu);
                        updateHistoryTable('memoryHistory', data.history.memory);
                        updateCharts(data.history);
                    }
                    
                    // Update timestamp
                    document.getElementById('lastUpdated').textContent = 'Last updated: ' + new Date().toLocaleTimeString();
                    
                    return data;
                })
                .catch(error => {
                    console.error('Error fetching server data:', error);
                    alert('Failed to fetch server data. Please try again later.');
                    return Promise.reject(error);
                });
        }
        
        // Main fetch data function
        function fetchData() {
            // Set button to loading state
            const refreshBtn = document.getElementById('refreshBtn');
            const btnOriginalContent = refreshBtn.innerHTML;
            
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Loading...';
            
            let apiPromise;
            
            if (currentServerId) {
                // Fetch data for the selected server
                apiPromise = fetchServerData(currentServerId);
            } else {
                // If no server is selected, fetch the server list
                apiPromise = fetchServerList().then(() => {
                    if (serverList.length > 0) {
                        // Select the first server if available
                        currentServerId = serverList[0].id;
                        document.getElementById('serverSelector').value = currentServerId;
                        return fetchServerData(currentServerId);
                    }
                    return Promise.reject(new Error('No servers available'));
                });
            }
            
            return apiPromise
                .finally(() => {
                    // Reset button state
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = btnOriginalContent;
                });
        }
        
        // Initialize everything when the document is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Setup server selector change event
            document.getElementById('serverSelector').addEventListener('change', function() {
                const serverId = this.value;
                if (serverId) {
                    currentServerId = serverId;
                    fetchServerData(serverId);
                }
            });
            
            // Refresh button click handler with animation
            document.getElementById('refreshBtn').addEventListener('click', function() {
                // Add rotating animation class
                this.querySelector('i').classList.add('spin-animation');
                
                if (currentServerId) {
                    fetchServerData(currentServerId).finally(() => {
                        // Remove animation class when done
                        setTimeout(() => this.querySelector('i').classList.remove('spin-animation'), 500);
                    });
                } else {
                    fetchData().finally(() => {
                        // Remove animation class when done
                        setTimeout(() => this.querySelector('i').classList.remove('spin-animation'), 500);
                    });
                }
            });
            
            // CPU history toggle
            document.getElementById('cpuHistoryToggle').addEventListener('click', function() {
                const table = document.getElementById('cpuHistoryTable');
                const isExpanded = table.classList.toggle('expanded');
                const icon = this.querySelector('i');
                
                if (isExpanded) {
                    this.firstChild.textContent = 'Show less ';
                    icon.className = 'bi bi-chevron-up';
                } else {
                    this.firstChild.textContent = 'Show more ';
                    icon.className = 'bi bi-chevron-down';
                }
            });
            
            // Memory history toggle
            document.getElementById('memoryHistoryToggle').addEventListener('click', function() {
                const table = document.getElementById('memoryHistoryTable');
                const isExpanded = table.classList.toggle('expanded');
                const icon = this.querySelector('i');
                
                if (isExpanded) {
                    this.firstChild.textContent = 'Show less ';
                    icon.className = 'bi bi-chevron-up';
                } else {
                    this.firstChild.textContent = 'Show more ';
                    icon.className = 'bi bi-chevron-down';
                }
            });
            
            // Update clock
            updateClock();
            setInterval(updateClock, 1000);
            
            // Setup auto-refresh
            setupAutoRefresh();
            
            // Initialize charts
            initCharts();
            
            // Fetch initial data
            fetchServerList().then(() => {
                console.log('Initial data fetch complete');
                
                // Default to a 10-second refresh for demo
                document.querySelector('.refresh-option[data-seconds="10"]').click();
            });
        });
    </script>
</body>
</html>